---
title: "2D_example"
author: "Zian Wang"
date: "2/7/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
```

```{r}
library(lhs)
```

```{r}
library(GPfit)
```



## 2D examples  

In this file, we will apply the Bayesian optimization to 2D problems.  

### Rosenbrock function  



```{r define_the_function}
### Since GPfit only supports x in range [0,1], we will map all the inputs into [0,1]
transform_input <- function(x, x_lwr, x_upr)
{
  (x - x_lwr) / (x_upr - x_lwr)
}
recover_input <- function(x, x_lwr, x_upr) {
  return(x*(x_upr - x_lwr) + x_lwr)
}

f <- function(x1, x2, x1_lwr, x1_upr,x2_lwr, x2_upr) {
  x1 <- recover_input(x1, x1_lwr, x1_upr)
  x2 <- recover_input(x2, x2_lwr, x2_upr)
  return(log10(100*(x2-x1^2)^2 + (1-x1)^2))
}
```


```{r}
pipe <- function(ini_guess, acquisition_function, iteration, x1_lwr, x1_upr, x2_lwr, x2_upr, kappa = 2) {
  ### Firstly map the initial guess into [0,1]
  ini_guess <- ini_guess %>% mutate(x1 = transform_input(x1, x1_lwr, x1_upr)) %>% mutate(x2 = transform_input(x2, x2_lwr, x2_upr))
  ### Calculate the acquisition function value
  calculate <- function(pred_mean, pred_sd, y_best) {
    if(pred_sd == 0) {
      return(0)
    }
    else {
      value <- switch(acquisition_function,
          "Probability of improvement" = {pnorm((y_best-pred_mean)/pred_sd)},
          "Expected improvement" = {z_score <- (y_best-pred_mean)/pred_sd
                                    cdf_z <- pnorm(z_score)
                                    pred_sd*(z_score*cdf_z+dnorm(z_score))})
     return(value)
    }
  }
  
  ###
  run_acquisition <- function(df, x_new, kappa) {
    ### Fit Gaussian process
    my_gp <- GP_fit(X = df[,1:2], Y = df$y,
                    corr = list(type = "exponential", power = 2))
    ### Make predictions
    my_pred <- predict.GP(my_gp, xnew = x_new)
    ### Current min
    y_min <- min(df$y)
    ### Iterate over predictions
    switch(acquisition_function,
      "Confidence lower bound" = {my_pred$Y_hat - kappa*sqrt(my_pred$MSE)},
      {map2_dbl(my_pred$Y_hat, sqrt(my_pred$MSE),
                calculate, y_best = y_min)})
  }
  
  ### Initialize the data
  # df_x1 <- rep(seq(0, 1, length.out = 101), 101)
  # df_x2 <- vector()
  # for(i in seq(0, 1, length.out = 101)) {
  #   df_x2 <- c(df_x2, rep(i, 101))
  # }
  # df_new <- data.frame(x1 = df_x1,
  #                      x2 = df_x2)
  df_new <- expand.grid(x1 = seq(0,1, length.out = 101),
                        x2 = seq(0,1, length.out = 101),
                        KEEP.OUT.ATTRS = FALSE, 
                        stringsAsFactors = FALSE) %>% 
    as.data.frame()
  evaluation <- ini_guess %>% mutate(iteration = 0)
  acq_data <- data.frame()
  data <- data.frame()
  
  pred_list_obj <- vector(mode = 'list', length = iteration+1)
  
  ### Run the iteration
  t <- 0
  for(t in 0:iteration) {
    ### Gaussian process
    browser()
    fit <- GP_fit(
     X = evaluation %>% select(x1, x2) %>% as.matrix(),
     Y = evaluation$y,
     corr = list(type = "exponential", power = 2)
    )
    pred_from_gp <- predict.GP(fit, xnew = df_new)$complete_data %>%
      as.data.frame() %>%
      mutate(iteration = t)
    pred_list_obj[[t+1]] <- pred_from_gp
    data <- rbind(data, pred_from_gp)
    
    ### Calculate the acquisition function
    temp_df <- df_new %>%
      mutate(acq_value = run_acquisition(evaluation, df_new, kappa)) %>%
      mutate(iteration = t+1)
    acq_data <- rbind(acq_data, temp_df)
    if(acquisition_function == "Confidence lower bound") {
      x_next <- df_new$x[which.min(temp_df$acq_value)]
    }
    else {
      x_next <- c(df_new$x1[which.max(temp_df$acq_value)], 
                  df_new$x2[which.max(temp_df$acq_value)])
    }
    evaluation[nrow(evaluation)+1,] <- c(x_next, f(x_next[1], x_next[2], x1_lwr, x1_upr, x2_lwr, x2_upr), t+1)
  }
  ### Calculate the last iteration's data
  fit <- GP_fit(
    X = evaluation[,1:2],
    Y = evaluation$y,
    corr = list(type = "exponential", power = 2)
  )
  pred_from_gp <- predict.GP(fit, xnew = df_new)$complete_data %>%
    as.data.frame() %>%
    mutate(iteration = t)
  data <- rbind(data, pred_from_gp)
  
  ### Recover the x1 and x2 to original space.
  evaluation <- evaluation %>% 
    mutate(x1 = recover_input(x1, x1_lwr, x1_upr)) %>%
    mutate(x2 = recover_input(x2, x2_lwr, x2_upr))
  acq_data <- acq_data %>% 
    mutate(x1 = recover_input(x1, x1_lwr, x1_upr)) %>%
    mutate(x2 = recover_input(x2, x2_lwr, x2_upr))
  
  return(list(pred_data = data, evaluation = evaluation, acq_data = acq_data))
}
```

```{r}
set.seed(11111)
x_design <- maximinLHS(n = 4, k = 2) %>% as.matrix() %>% as.data.frame() %>%
  purrr::set_names(c("x1", "x2"))
```

```{r}
x_design %>% ggplot(mapping = aes(x = x1, y = x2)) +
  geom_point() +
  coord_equal(xlim = c(0, 1), ylim = c(0, 1)) +
  theme_bw()
```

```{r}
x_design <- x_design %>% 
  mutate(y = f(x1, x2, -2, 2, -1, 3))
```

```{r}
res <- pipe(x_design, "Probability of improvement", 9, -2, 2, -1, 3)
```





```{r}
acq_plots <- function(acq_data, evaluation) {
  ### Acquisition function's plot
  plot_1 <- acq_data %>% ggplot() +
    geom_raster(mapping = aes(x = x1, y = x2, fill = acq_value)) +
  geom_contour(mapping = aes(x = x1, y = x2, z = acq_value),
               color = 'white') +
<<<<<<< HEAD
    geom_point(data = evaluation[(nrow(ini_guess)+1):nrow(evaluation),], 
=======
    geom_point(data = evaluation %>% filter(iteration > 0), 
>>>>>>> 86c60f3a4e96ff9669f68f411e948c1b48cf677e
               mapping = aes(x = x1, y = x2),
               color = "red", size = 3) +
    facet_wrap(~ iteration) +
    scale_fill_viridis_c() +
    theme_bw()
  
  print(plot_1)
  
}
```


```{r}
acq_plots(res$acq_data, res$evaluation)
```

```{r}
gp_pred_mean_plot <- function(pred_data) {
  pred_data %>% 
    ggplot(mapping = aes(x = xnew.1, y = xnew.2)) +
    geom_raster(mapping = aes(fill = Y_hat)) +
    coord_equal() +
    facet_wrap(~ iteration) +
    scale_fill_viridis_c(option = "E") +
    theme_bw()
}
```

```{r}
gp_pred_mean_plot(res$pred_data)
```

```{r}
gp_pred_sd_plot <- function(pred_data) {
  pred_data %>% 
    ggplot(mapping = aes(x = xnew.1, y = xnew.2)) +
    geom_raster(mapping = aes(fill = MSE)) +
    coord_equal() +
    facet_wrap(~ iteration) +
    scale_fill_viridis_c(option = "A") +
    theme_bw()
}
```

```{r}
gp_pred_sd_plot(res$pred_data)
```

```{r}
gp_pred_sd_plot_2 <- function(pred_data, evaluation) {
  pred_data %>% 
    ggplot(mapping = aes(x = xnew.1, y = xnew.2)) +
    geom_raster(mapping = aes(fill = MSE)) +
    geom_point(data = evaluation %>% 
                 mutate(x1 = transform_input(x1, -2, 2),
                        x2 = transform_input(x2, -1, 3)), 
               mapping = aes(x = x1, y = x2), 
               shape = 0, color = "cyan") +
    coord_equal() +
    facet_wrap(~ iteration) +
    scale_fill_viridis_c(option = "A") +
    theme_bw()
}
```


```{r}
gp_pred_sd_plot_2(res$pred_data, res$evaluation)
```



```{r}
make_plots <- function() {
  
  x1_plot <- rep(seq(-2, 2, length.out = 101), 101)
  x2_plot <- vector()
  for (t in seq(-1, 3, length.out = 101)) {
    x2_plot <- c(x2_plot, rep(t, 101))
  }
  plot_data <- data.frame(x1 = x1_plot, x2 = x2_plot, y = f(x1_plot, x2_plot, x1_lwr, x1_upr, x2_lwr, x2_upr))
  plot_2 <- evaluation %>% filter(iteration > 0) %>% 
    ggplot() +
    geom_raster(mapping = aes(x = x1, y = x2, fill = log(y))) +
  geom_contour(mapping = aes(x = x1, y = x2, z = log(y)),
               color = 'white') +
    geom_point(mapping = aes(x = x1, y = x2),
               color = "red",
               size = 3) +
    facet_wrap(~ iteration) +
    theme_bw()


  print(plot_2)
}
```






```{r}
x1_plot <- rep(seq(-2, 2, length.out = 101), 101)
x2_plot <- vector()
for (t in seq(-1, 3, length.out = 101)) {
  x2_plot <- c(x2_plot, rep(t, 101))
}
plot_data <- data.frame(x1 = x1_plot, x2 = x2_plot, y = f(x1_plot, x2_plot, -2, 2, -1, 3))
plot_data %>% ggplot() +
  geom_contour_filled(mapping = aes(x = x1, y = x2, z = y), 
                      breaks = c(-Inf, 10^-3, 10^-2, 10^-1, 1, 10, 100, 1000, Inf)) +
  theme_bw()
```


```{r}
set.seed(123)
ini_set <- maximinLHS(n = 4, k = 2, maxIter = 5001, eps=0.01,
                           optimize.on = 'result', method = 'iterative')
ini_set <- ini_set %>% as.data.frame()
colnames(ini_set) <- c("x1", "x2")
ini_set <- ini_set %>% 
  mutate(x1 = x1*4-2) %>% 
  mutate(x2 = x2*4-1) %>% 
  mutate(y = f(x1, x2, -2, 2, -1, 3))

ini_set %>% ggplot() +
  geom_point(mapping = aes(x = x1, y = x2)) +
  theme_bw()
```


```{r}
library(dplyr)
library(GPfit)
library(tidyverse)
x <- data.frame(x1=1, x2=2)
res <- pipe(ini_set, "Probability of improvement", 15, -2, 2, -1, 3)
```






